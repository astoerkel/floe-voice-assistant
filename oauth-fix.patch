diff --git a/voice-assistant-backend/src/controllers/voice.controller.js b/voice-assistant-backend/src/controllers/voice.controller.js
index ed719ac0..82a53245 100644
--- a/voice-assistant-backend/src/controllers/voice.controller.js
+++ b/voice-assistant-backend/src/controllers/voice.controller.js
@@ -23,7 +23,7 @@ class VoiceController {
         return res.status(400).json({ error: 'Validation failed', details: errors.array() });
       }
 
-      const { text, context = {}, platform = 'ios' } = req.body;
+      const { text, context = {}, platform = 'ios', integrations = {} } = req.body;
       const userId = req.user.id;
       
       // Validate input
@@ -68,7 +68,8 @@ class VoiceController {
         userId,
         transcriptionMethod: 'apple_speech',
         sessionId: context.sessionId || `session_${Date.now()}_${userId}`,
-        startTime
+        startTime,
+        integrations // Pass OAuth integration status from iOS app
       };
 
       // Try new LangChain coordinator first, fallback to legacy on failure
@@ -114,37 +115,53 @@ class VoiceController {
         hasValidResponse,
         hasValidAudio,
         overallSuccess,
-        userId
+        userId,
+        responseLength: result.response?.length || 0,
+        audioDataSize: audioResponse?.audioBase64?.length || 0
+      });
+
+      // Log the exact response format being sent to iOS for debugging
+      logger.info('Sending response to iOS:', {
+        success: overallSuccess,
+        textLength: result.response?.length || 0,
+        hasAudioBase64: !!audioResponse?.audioBase64,
+        audioBase64Length: audioResponse?.audioBase64?.length || 0
       });
 
+      // Return format expected by iOS app: { success: boolean, text: string, audioBase64: string }
       res.json({
         success: overallSuccess,
+        text: result.response, // The actual response text (not nested)
+        audioBase64: audioResponse?.audioBase64 || null, // Direct audio data (not nested)
+        // Additional fields for debugging and features
         processingTime,
         transcriptionMethod: 'apple_speech',
-        text: text,
         intent: result.intent,
         confidence: result.confidence,
         agentUsed: result.agentUsed || result.agent,
         executionTime: result.executionTime,
-        response: {
-          text: result.response,
-          audioUrl: audioResponse?.audioBase64 ? `data:audio/mp3;base64,${audioResponse.audioBase64}` : null,
-          hapticPattern: this.getHapticPattern(result.intent || result.action?.type)
-        },
-        audioResponse,
         action: result.action,
         actions: result.actions || [],
         suggestions: result.suggestions || [],
         sessionId: enhancedContext.sessionId,
         usage: result.usage || {},
         coordinatorUsed: result.agentUsed ? 'langchain' : 'legacy',
-        // Include coordinator success for debugging
-        coordinatorSuccess: result.success
+        coordinatorSuccess: result.success,
+        // Legacy format for backward compatibility (but iOS should use the flat fields above)
+        response: {
+          text: result.response,
+          audioUrl: audioResponse?.audioBase64 ? `data:audio/mp3;base64,${audioResponse.audioBase64}` : null,
+          hapticPattern: this.getHapticPattern(result.intent || result.action?.type)
+        },
+        audioResponse
       });
       
     } catch (error) {
       logger.error('Text processing error:', error);
       res.status(500).json({
+        success: false,
+        text: "I'm sorry, I encountered an error processing your request. Please try again.",
+        audioBase64: null,
         error: error.message,
         processingTime: Date.now() - startTime,
         fallbackSuggestion: 'Try using audio upload endpoint'
@@ -239,8 +256,12 @@ class VoiceController {
       const hasValidAudio = audioResponse?.audioBase64;
       const overallSuccess = hasValidAudio || hasValidResponse;
 
+      // Return format expected by iOS app: { success: boolean, text: string, audioBase64: string }
       res.json({
         success: overallSuccess,
+        text: result.response, // The actual response text (not nested)
+        audioBase64: audioResponse?.audioBase64 || null, // Direct audio data (not nested)
+        // Additional fields for debugging and features
         processingTime: totalProcessingTime,
         transcriptionTime,
         transcriptionMethod: 'whisper',
@@ -249,8 +270,6 @@ class VoiceController {
           confidence: transcriptionResult.confidence,
           language: transcriptionResult.language
         },
-        response: result.response,
-        audioResponse,
         intent: result.intent,
         confidence: result.confidence,
         agentUsed: result.agentUsed,
@@ -258,15 +277,20 @@ class VoiceController {
         actions: result.actions || [],
         suggestions: result.suggestions || [],
         sessionId,
+        coordinatorSuccess: result.success,
+        // Legacy format for backward compatibility
+        response: result.response,
+        audioResponse,
         updates: {
           hapticPattern: this.getHapticPattern(result.intent)
-        },
-        // Include coordinator success for debugging
-        coordinatorSuccess: result.success
+        }
       });
     } catch (error) {
       logger.error('Voice audio processing failed:', error);
       res.status(500).json({ 
+        success: false,
+        text: "I'm sorry, I had trouble processing your audio. Please try again.",
+        audioBase64: null,
         error: 'Voice audio processing failed',
         message: error.message 
       });
@@ -319,10 +343,12 @@ class VoiceController {
       const hasValidAudio = audioResponse?.audioBase64;
       const overallSuccess = hasValidAudio || hasValidResponse;
 
+      // Return format expected by iOS app: { success: boolean, text: string, audioBase64: string }
       res.json({
         success: overallSuccess,
-        response: result.response,
-        audioResponse,
+        text: result.response, // The actual response text (not nested)
+        audioBase64: audioResponse?.audioBase64 || null, // Direct audio data (not nested)
+        // Additional fields for debugging and features
         intent: result.intent,
         confidence: result.confidence,
         agentUsed: result.agentUsed,
@@ -330,12 +356,17 @@ class VoiceController {
         actions: result.actions || [],
         suggestions: result.suggestions || [],
         sessionId,
-        // Include coordinator success for debugging
-        coordinatorSuccess: result.success
+        coordinatorSuccess: result.success,
+        // Legacy format for backward compatibility
+        response: result.response,
+        audioResponse
       });
     } catch (error) {
       logger.error('Voice processing failed:', error);
       res.status(500).json({ 
+        success: false,
+        text: "I'm sorry, I encountered an error processing your request. Please try again.",
+        audioBase64: null,
         error: 'Voice processing failed',
         message: error.message 
       });
@@ -808,18 +839,21 @@ class VoiceController {
         const hasValidAudio = audioResponse?.audioBase64;
         const overallSuccess = hasValidAudio || (hasValidResponse && result.success !== false);
 
+        // Return format expected by iOS app: { success: boolean, text: string, audioBase64: string }
         res.json({
           success: overallSuccess,
           final: true,
-          text: text,
+          text: result.response, // The actual response text (not nested)
+          audioBase64: audioResponse?.audioBase64 || null, // Direct audio data (not nested)
+          // Additional fields for debugging and features
           intent: result.intent,
-          response: result.response,
-          audioResponse,
+          coordinatorSuccess: result.success,
           updates: {
             hapticPattern: this.getHapticPattern(result.intent)
           },
-          // Include coordinator success for debugging
-          coordinatorSuccess: result.success
+          // Legacy format for backward compatibility
+          response: result.response,
+          audioResponse
         });
       } else {
         // Handle partial results
@@ -831,7 +865,12 @@ class VoiceController {
       }
     } catch (error) {
       logger.error('Stream process failed:', error);
-      res.status(500).json({ error: 'Stream process failed' });
+      res.status(500).json({ 
+        success: false,
+        text: "I'm sorry, I had trouble with the streaming request. Please try again.",
+        audioBase64: null,
+        error: 'Stream process failed' 
+      });
     }
   }
 
diff --git a/voice-assistant-backend/src/services/agents/emailAgent.js b/voice-assistant-backend/src/services/agents/emailAgent.js
index e6f46562..d5a3b95b 100644
--- a/voice-assistant-backend/src/services/agents/emailAgent.js
+++ b/voice-assistant-backend/src/services/agents/emailAgent.js
@@ -1,10 +1,12 @@
 const { Tool } = require('langchain/tools');
 const { prisma } = require('../../config/database');
 const logger = require('../../utils/logger');
+const GmailIntegration = require('../integrations/google/gmail');
 
 class EmailAgent {
   constructor() {
     this.agentName = 'email';
+    this.gmailService = new GmailIntegration();
     this.tools = this.createTools();
   }
 
@@ -162,7 +164,16 @@ class EmailAgent {
   async handleGetEmails(userId, intent, context) {
     try {
       const limit = intent.filter === 'recent' ? 5 : 10;
-      const emails = await this.getEmails(userId, intent.filter, limit);
+      const emails = await this.getEmails(userId, intent.filter, limit, context);
+      
+      // Check if Google isn't connected
+      if (emails.notConnected) {
+        return {
+          text: "I can see your Google account is connected, but I'm having trouble accessing your emails. Let me check your connection status.",
+          actions: [],
+          suggestions: ['Check connection status', 'Try again', 'Reconnect Google']
+        };
+      }
       
       if (emails.length === 0) {
         const filterText = intent.filter === 'unread' ? 'unread emails' : 
@@ -325,81 +336,83 @@ class EmailAgent {
   }
 
   // Email data management methods
-  async getEmails(userId, filter = 'all', limit = 10) {
+  async getEmails(userId, filter = 'all', limit = 10, context = {}) {
     try {
-      // For now, return mock data. In a real implementation, this would:
-      // 1. Check user's Gmail integration
-      // 2. Fetch emails from Gmail API
-      // 3. Apply filters and return formatted emails
+      // Check if Gmail integration is active from iOS app context first
+      const isActiveFromContext = context?.integrations?.google?.connected === true;
       
-      const mockEmails = [
-        {
-          id: 'email1',
-          subject: 'Team Meeting Tomorrow',
-          sender: 'john@company.com',
-          senderName: 'John Smith',
-          body: 'Hi team, reminder about our meeting tomorrow at 2 PM in the conference room.',
-          timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2 hours ago
-          isRead: false,
-          isImportant: true
-        },
-        {
-          id: 'email2',
-          subject: 'Project Update',
-          sender: 'jane@company.com',
-          senderName: 'Jane Doe',
-          body: 'Here is the latest update on the project status...',
-          timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000), // 4 hours ago
-          isRead: false,
-          isImportant: false
-        },
-        {
-          id: 'email3',
-          subject: 'Weekly Report',
-          sender: 'manager@company.com',
-          senderName: 'Manager',
-          body: 'Please find the weekly report attached.',
-          timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000), // 1 day ago
-          isRead: true,
-          isImportant: false
-        }
-      ];
-      
-      let filteredEmails = mockEmails;
+      // Only check database if context doesn't provide integration status
+      let isActive = isActiveFromContext;
+      if (!context?.integrations) {
+        isActive = await this.gmailService.isIntegrationActive(userId);
+      }
       
+      if (!isActive) {
+        logger.warn(`Gmail integration not active for user ${userId} (context: ${isActiveFromContext}, db check: ${!context?.integrations})`);
+        // Return a special indicator that Google isn't connected
+        return { notConnected: true };
+      }
+
+      let query = '';
       switch (filter) {
         case 'unread':
-          filteredEmails = mockEmails.filter(email => !email.isRead);
+          query = 'is:unread';
           break;
         case 'important':
-          filteredEmails = mockEmails.filter(email => email.isImportant);
+          query = 'is:important';
           break;
         case 'recent':
-          filteredEmails = mockEmails.filter(email => 
-            email.timestamp > new Date(Date.now() - 6 * 60 * 60 * 1000) // Last 6 hours
-          );
+          // Get emails from last 6 hours
+          const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);
+          const dateFilter = sixHoursAgo.toISOString().split('T')[0].replace(/-/g, '/');
+          query = `after:${dateFilter}`;
           break;
         default:
-          filteredEmails = mockEmails;
+          query = '';
       }
       
-      return filteredEmails.slice(0, limit);
+      const emails = await this.gmailService.getEmails(userId, {
+        query,
+        limit,
+        includeSpamTrash: false
+      });
+      
+      // Transform Gmail format to agent format for backwards compatibility
+      return emails.map(email => ({
+        id: email.id,
+        subject: email.subject || '(No Subject)',
+        sender: email.sender || 'Unknown Sender',
+        senderName: this.extractSenderName(email.sender),
+        body: email.body || email.snippet || '',
+        timestamp: email.timestamp,
+        isRead: email.isRead,
+        isImportant: email.isImportant,
+        snippet: email.snippet
+      }));
     } catch (error) {
       logger.error('Get emails failed:', error);
+      // Return empty array on error instead of mock data
       return [];
     }
   }
 
   async sendEmail(emailData) {
     try {
-      // For now, return mock data. In a real implementation, this would:
-      // 1. Validate email data
-      // 2. Send email via Gmail API
-      // 3. Store sent email reference
-      // 4. Return confirmation
+      // Check if Gmail integration is active
+      const isActive = await this.gmailService.isIntegrationActive(emailData.userId);
+      if (!isActive) {
+        throw new Error('Gmail integration not active for user');
+      }
+
+      const result = await this.gmailService.sendEmail(emailData.userId, {
+        to: emailData.recipient,
+        subject: emailData.subject,
+        body: emailData.body || 'Sent via voice assistant'
+      });
       
-      const mockEmail = {
-        id: `email_${Date.now()}`,
+      logger.info('Email sent via Gmail API:', result);
+      return {
+        id: result.id,
         recipient: emailData.recipient,
         subject: emailData.subject,
         body: emailData.body || 'Sent via voice assistant',
@@ -407,39 +420,48 @@ class EmailAgent {
         userId: emailData.userId,
         status: 'sent'
       };
-      
-      logger.info('Email sent:', mockEmail);
-      return mockEmail;
     } catch (error) {
       logger.error('Send email failed:', error);
       throw error;
     }
   }
 
-  async replyToEmail(emailId, replyText) {
+  async replyToEmail(userId, emailId, replyText) {
     try {
-      // Mock implementation
-      const mockReply = {
-        id: `reply_${Date.now()}`,
+      // Check if Gmail integration is active
+      const isActive = await this.gmailService.isIntegrationActive(userId);
+      if (!isActive) {
+        throw new Error('Gmail integration not active for user');
+      }
+
+      const result = await this.gmailService.replyToEmail(userId, emailId, replyText);
+      
+      logger.info('Email reply sent via Gmail API:', result);
+      return {
+        id: result.id,
         originalEmailId: emailId,
         body: replyText,
         timestamp: new Date(),
         status: 'sent'
       };
-      
-      logger.info('Email reply sent:', mockReply);
-      return mockReply;
     } catch (error) {
       logger.error('Reply to email failed:', error);
       throw error;
     }
   }
 
-  async markEmailRead(emailId) {
+  async markEmailRead(userId, emailId) {
     try {
-      // Mock implementation
-      logger.info('Email marked as read:', emailId);
-      return { id: emailId, isRead: true };
+      // Check if Gmail integration is active
+      const isActive = await this.gmailService.isIntegrationActive(userId);
+      if (!isActive) {
+        throw new Error('Gmail integration not active for user');
+      }
+
+      const result = await this.gmailService.markAsRead(userId, emailId);
+      
+      logger.info('Email marked as read via Gmail API:', emailId);
+      return { id: emailId, isRead: true, success: result.success };
     } catch (error) {
       logger.error('Mark email read failed:', error);
       throw error;
@@ -448,16 +470,27 @@ class EmailAgent {
 
   async searchEmails(userId, query, limit = 10) {
     try {
-      // Mock implementation - search in mock emails
-      const mockEmails = await this.getEmails(userId, 'all', 50);
-      
-      const searchResults = mockEmails.filter(email => 
-        email.subject.toLowerCase().includes(query.toLowerCase()) ||
-        email.body.toLowerCase().includes(query.toLowerCase()) ||
-        email.senderName.toLowerCase().includes(query.toLowerCase())
-      );
+      // Check if Gmail integration is active
+      const isActive = await this.gmailService.isIntegrationActive(userId);
+      if (!isActive) {
+        logger.warn(`Gmail integration not active for user ${userId}`);
+        return [];
+      }
+
+      const emails = await this.gmailService.searchEmails(userId, query, limit);
       
-      return searchResults.slice(0, limit);
+      // Transform Gmail format to agent format for backwards compatibility
+      return emails.map(email => ({
+        id: email.id,
+        subject: email.subject || '(No Subject)',
+        sender: email.sender || 'Unknown Sender',
+        senderName: this.extractSenderName(email.sender),
+        body: email.body || email.snippet || '',
+        timestamp: email.timestamp,
+        isRead: email.isRead,
+        isImportant: email.isImportant,
+        snippet: email.snippet
+      }));
     } catch (error) {
       logger.error('Search emails failed:', error);
       return [];
@@ -465,6 +498,19 @@ class EmailAgent {
   }
 
   // Utility methods
+  extractSenderName(senderString) {
+    if (!senderString) return 'Unknown Sender';
+    
+    // Extract name from "Name <email@domain.com>" format
+    const nameMatch = senderString.match(/^([^<]+)<.+>$/);
+    if (nameMatch) {
+      return nameMatch[1].trim();
+    }
+    
+    // If no name part, return email address
+    return senderString;
+  }
+
   parseEmailDetails(input) {
     // Simple parsing - in a real implementation, this would use NLP
     const emailDetails = {
